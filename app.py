#!/usr/bin/env python3
"""
Simple Flask web UI for youtube_cutter.py.
Allows entering pause, fade, and segment triples, runs the cutter,
and serves the resulting output file for download.
"""
import os
import uuid
import subprocess
from flask import Flask, render_template, request, send_from_directory, redirect, url_for
from werkzeug.utils import secure_filename
from mutagen.easyid3 import EasyID3
from mutagen.id3 import ID3NoHeaderError
import zipfile
import re
import sys
import urllib.request

# Create outputs directory
OUTPUT_ROOT = os.path.join(os.path.dirname(__file__), 'outputs')
os.makedirs(OUTPUT_ROOT, exist_ok=True)

app = Flask(__name__)


@app.route('/', methods=['GET', 'POST'])
def index():
    logs = None
    download_url = None
    # retain form values across requests
    job_id = ''
    pause = '0'
    start_fade = '0'
    fade_out = '0'
    fade_in = '0'
    end_fade = '0'
    segments = ''
    output_name = 'audio_cut_join_out'
    # multi-downloader video state
    multi_logs = None
    multi_download_url = None
    multi_urls = ''
    # multi-downloader audio state
    multi_logs_audio = None
    multi_download_url_audio = None
    multi_urls_audio = ''
    # multi-downloader spotify state
    multi_logs_spotify = None
    multi_download_url_spotify = None
    multi_urls_spotify = ''
    if request.method == 'POST':
        pause = request.form.get('pause', '0').strip()
        start_fade = request.form.get('start_fade', '0').strip()
        fade_out   = request.form.get('fade_out', '0').strip()
        fade_in    = request.form.get('fade_in', '0').strip()
        end_fade   = request.form.get('end_fade', '0').strip()
        segments   = request.form.get('segments', '').strip()
        output_name = request.form.get('output_name', '').strip() or 'audio_cut_join_out'
        segments_text = segments.splitlines()

        # Determine job ID (reuse if re-running, otherwise generate new)
        job_id = request.form.get('job_id') or uuid.uuid4().hex
        out_dir = os.path.join(OUTPUT_ROOT, job_id)
        os.makedirs(out_dir, exist_ok=True)

        # Collect existing uploaded MP3s (from prior run) and add new uploads
        existing = [f for f in os.listdir(out_dir) if f.lower().endswith('.mp3')]
        uploaded = request.files.getlist('files')
        warn_msgs = []
        for f in uploaded:
            if f and f.filename:
                fname = secure_filename(f.filename)
                if fname not in existing:
                    existing.append(fname)
                    f.save(os.path.join(out_dir, fname))
        if len(existing) > 9:
            warn_msgs.append(
                f"Warning: only first 9 uploaded files will be used (you uploaded {len(existing)})"
            )
            existing = existing[:9]
        uploaded_names = existing

        # Build args list: pause, start_fade, fade_out, fade_in, end_fade, then segment tokens
        args = [pause, start_fade, fade_out, fade_in, end_fade]
        for line in segments_text:
            parts = line.strip().split()
            if parts:
                args.extend(parts)

        # Base path for output file (filename will be output_name.ext)
        out_base = os.path.join(out_dir, output_name)

        # Invoke youtube_cutter script
        cmd = ['python3', 'youtube_cutter.py'] + args + ['-o', out_base]
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        logs, _ = proc.communicate()

        # Determine output file name (pick the generated "output" file)
        files_in_out = os.listdir(out_dir)
        # look for output.* file generated by youtube_cutter
        basename = os.path.basename(out_base)
        out_candidates = [f for f in files_in_out if f.startswith(basename)]
        if out_candidates:
            out_fname = out_candidates[0]
            # Update MP3 metadata title tag to filename (without extension)
            if out_fname.lower().endswith('.mp3'):
                try:
                    file_path = os.path.join(out_dir, out_fname)
                    song_title = os.path.splitext(out_fname)[0]
                    try:
                        audio = EasyID3(file_path)
                    except ID3NoHeaderError:
                        audio = EasyID3()
                        audio.save(file_path)
                    audio['title'] = song_title
                    audio.save(file_path)
                except Exception as e:
                    logs = (logs or '') + f"\nError updating metadata for {out_fname}: {e}"
            download_url = f'/download/{job_id}/{out_fname}'
        # prepend any warnings to logs
        if warn_msgs:
            logs = '\n'.join(warn_msgs + ([logs] if logs else []))

    return render_template(
        'index.html',
        job_id=job_id,
        logs=logs,
        download_url=download_url,
        pause=pause,
        start_fade=start_fade,
        fade_out=fade_out,
        fade_in=fade_in,
        end_fade=end_fade,
        segments=segments,
        output_name=output_name,
        multi_logs=multi_logs,
        multi_download_url=multi_download_url,
        multi_urls=multi_urls,
        multi_logs_audio=multi_logs_audio,
        multi_download_url_audio=multi_download_url_audio,
        multi_urls_audio=multi_urls_audio,
        multi_logs_spotify=multi_logs_spotify,
        multi_download_url_spotify=multi_download_url_spotify,
        multi_urls_spotify=multi_urls_spotify,
    )


@app.route('/download/<job_id>/<filename>')
def download(job_id, filename):
    dirpath = os.path.join(OUTPUT_ROOT, job_id)
    return send_from_directory(dirpath, filename, as_attachment=True)


@app.route('/multi-download', methods=['GET', 'POST'])
def multi_download():
    """Download multiple YouTube URLs and zip the results."""
    # GET: redirect back to main page
    if request.method == 'GET':
        print("[multi_download] GET -- redirecting to index", file=sys.stderr)
        return redirect(url_for('index'))

    # New job directory
    job_id = uuid.uuid4().hex
    out_dir = os.path.join(OUTPUT_ROOT, job_id)
    os.makedirs(out_dir, exist_ok=True)

    print("[multi_download] POST -- starting download", file=sys.stderr)
    # Read URLs list
    multi_urls = request.form.get('multi_urls', '').strip()
    urls = [u.strip() for u in multi_urls.splitlines() if u.strip()]
    multi_logs = ''

    # Download each URL via yt-dlp
    for url in urls:
        try:
            cmd = ['yt-dlp', '-o', os.path.join(out_dir, '%(title)s.%(ext)s'), url]
            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT, text=True)
            out, _ = proc.communicate()
            multi_logs += out + '\n'
        except Exception as exc:
            multi_logs += f"Error downloading {url}: {exc}\n"

    # Zip the downloaded files
    zip_name = 'youtube_multi.zip'
    zip_path = os.path.join(out_dir, zip_name)
    try:
        with zipfile.ZipFile(zip_path, 'w') as zf:
            for fname in os.listdir(out_dir):
                if fname == zip_name:
                    continue
                # Normalize filename: keep only alphanumeric in base, replace others with hyphen; preserve extension dot
                base, ext = os.path.splitext(fname)
                safe_base = re.sub(r'[^0-9A-Za-z]', '-', base)
                safe_name = f"{safe_base}{ext}"
                zf.write(os.path.join(out_dir, fname), arcname=safe_name)
    except Exception as exc:
        multi_logs += f"Error creating zip: {exc}\n"

    multi_download_url = f'/download/{job_id}/{zip_name}'
    # Render main page with multi-downloader context
    return render_template(
        'index.html',
        job_id='', logs=None, download_url=None,
        pause='', fade='', segments='',
        multi_logs=multi_logs,
        multi_download_url=multi_download_url,
        multi_urls=multi_urls,
        # reset audio downloader panel
        multi_logs_audio=None,
        multi_download_url_audio=None,
        multi_urls_audio='',
    )

@app.route('/multi-audio', methods=['GET', 'POST'])
def multi_audio_download():
    """Download multiple YouTube URLs as MP3 and zip the results."""
    if request.method == 'GET':
        print("[multi_audio_download] GET -- redirecting to index", file=sys.stderr)
        return redirect(url_for('index'))

    print("[multi_audio_download] POST -- starting audio download", file=sys.stderr)
    job_id = uuid.uuid4().hex
    out_dir = os.path.join(OUTPUT_ROOT, job_id)
    os.makedirs(out_dir, exist_ok=True)

    multi_urls_audio = request.form.get('multi_urls_audio', '').strip()
    urls = [u.strip() for u in multi_urls_audio.splitlines() if u.strip()]
    multi_logs_audio = ''

    for url in urls:
        try:
            cmd = [
                'yt-dlp', '-x', '--audio-format', 'mp3',
                '-o', os.path.join(out_dir, '%(title)s.%(ext)s'),
                url,
            ]
            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT, text=True)
            out, _ = proc.communicate()
            multi_logs_audio += out + '\n'
        except Exception as exc:
            multi_logs_audio += f"Error downloading {url}: {exc}\n"

    zip_name = 'youtube_audio_multi.zip'
    zip_path = os.path.join(out_dir, zip_name)
    try:
        with zipfile.ZipFile(zip_path, 'w') as zf:
            for fname in os.listdir(out_dir):
                if fname == zip_name:
                    continue
                base, ext = os.path.splitext(fname)
                safe_base = re.sub(r'[^0-9A-Za-z]', '-', base)
                safe_name = f"{safe_base}{ext}"
                zf.write(os.path.join(out_dir, fname), arcname=safe_name)
    except Exception as exc:
        multi_logs_audio += f"Error creating zip: {exc}\n"

    multi_download_url_audio = f'/download/{job_id}/{zip_name}'
    return render_template(
        'index.html', job_id='', logs=None, download_url=None,
        pause='', fade='', segments='',
        multi_logs=None, multi_download_url=None, multi_urls='',
        multi_logs_audio=multi_logs_audio,
        multi_download_url_audio=multi_download_url_audio,
    multi_urls_audio=multi_urls_audio,
    )

@app.route('/multi-spotify', methods=['GET', 'POST'])
def multi_spotify_download():
    """Download multiple Spotify URLs as audio and zip the results."""
    if request.method == 'GET':
        print("[multi_spotify_download] GET -- redirecting to index", file=sys.stderr)
        return redirect(url_for('index'))

    print("[multi_spotify_download] POST -- starting spotify download", file=sys.stderr)
    job_id = uuid.uuid4().hex
    out_dir = os.path.join(OUTPUT_ROOT, job_id)
    os.makedirs(out_dir, exist_ok=True)

    multi_urls_spotify = request.form.get('multi_urls_spotify', '').strip()
    urls = [u.strip() for u in multi_urls_spotify.splitlines() if u.strip()]
    multi_logs_spotify = ''

    # Directly use spotdl for full-track download
    zip_name = 'spotify_audio_multi.zip'
    zip_path = os.path.join(out_dir, zip_name)
    audio_files = []
    # Directly use spotdl for full-track download
    try:
        import spotdl  # noqa: F401
        multi_logs_spotify += "Downloading full-track via spotdl...\n"
        for url in urls:
            subprocess.run([
                'spotdl',
                '--output', out_dir,
                '--format', 'mp3',
                '--bitrate', '320k',
                'download',
                url
            ], check=True)
            multi_logs_spotify += f"Downloaded full track for {url}\n"
        audio_files = [f for f in os.listdir(out_dir) if f.lower().endswith('.mp3')]
    except ModuleNotFoundError:
        multi_logs_spotify += "spotdl not installed; install it to download Spotify tracks.\n"
        audio_files = []
    except Exception as exc:
        multi_logs_spotify += f"spotdl download error: {exc}\n"
    try:
        with zipfile.ZipFile(zip_path, 'w') as zf:
            for fname in os.listdir(out_dir):
                if fname == zip_name:
                    continue
                base, ext = os.path.splitext(fname)
                safe_base = re.sub(r'[^0-9A-Za-z]', '-', base)
                safe_name = f"{safe_base}{ext}"
                zf.write(os.path.join(out_dir, fname), arcname=safe_name)
    except Exception as exc:
        multi_logs_spotify += f"Error creating zip: {exc}\n"

    multi_download_url_spotify = f'/download/{job_id}/{zip_name}'
    return render_template(
        'index.html', job_id='', logs=None, download_url=None,
        pause='', fade='', segments='',
        multi_logs=None, multi_download_url=None, multi_urls='',
        multi_logs_audio=None, multi_download_url_audio=None, multi_urls_audio='',
        multi_logs_spotify=multi_logs_spotify,
        multi_download_url_spotify=multi_download_url_spotify,
        multi_urls_spotify=multi_urls_spotify,
    )

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8020, debug=True)
