#!/usr/bin/env python3
"""
Simple Flask web UI for youtube_cutter.py.
Allows entering pause, fade, and segment triples, runs the cutter,
and serves the resulting output file for download.
"""
import os
import uuid
import subprocess
from flask import Flask, render_template, request, send_from_directory
from werkzeug.utils import secure_filename

# Create outputs directory
OUTPUT_ROOT = os.path.join(os.path.dirname(__file__), 'outputs')
os.makedirs(OUTPUT_ROOT, exist_ok=True)

app = Flask(__name__)


@app.route('/', methods=['GET', 'POST'])
def index():
    logs = None
    download_url = None
    # retain form values (and job ID) across requests
    job_id = ''
    pause = ''
    fade = ''
    segments = ''
    if request.method == 'POST':
        pause = request.form.get('pause', '').strip()
        fade = request.form.get('fade', '').strip()
        segments = request.form.get('segments', '').strip()
        segments_text = segments.splitlines()

        # Determine job ID (reuse if re-running, otherwise generate new)
        job_id = request.form.get('job_id') or uuid.uuid4().hex
        out_dir = os.path.join(OUTPUT_ROOT, job_id)
        os.makedirs(out_dir, exist_ok=True)

        # Collect existing uploaded MP3s (from prior run) and add new uploads
        existing = [f for f in os.listdir(out_dir) if f.lower().endswith('.mp3')]
        uploaded = request.files.getlist('files')
        warn_msgs = []
        for f in uploaded:
            if f and f.filename:
                fname = secure_filename(f.filename)
                if fname not in existing:
                    existing.append(fname)
                    f.save(os.path.join(out_dir, fname))
        if len(existing) > 9:
            warn_msgs.append(
                f"Warning: only first 9 uploaded files will be used (you uploaded {len(existing)})"
            )
            existing = existing[:9]
        uploaded_names = existing

        # Build args list, substituting uploaded files paths if used
        args = [pause, fade]
        for line in segments_text:
            parts = line.strip().split()
            if len(parts) == 3:
                if parts[0] in uploaded_names:
                    parts[0] = os.path.join(out_dir, parts[0])
                args.extend(parts)

        # Base path for output file (will result in mashup_combined.mp3)
        out_base = os.path.join(out_dir, 'mashup_combined')

        # Invoke youtube_cutter script
        cmd = ['python3', 'youtube_cutter.py'] + args + ['-o', out_base]
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        logs, _ = proc.communicate()

        # Determine output file name (pick the generated "output" file)
        files_in_out = os.listdir(out_dir)
        # look for output.* file generated by youtube_cutter
        basename = os.path.basename(out_base)
        out_candidates = [f for f in files_in_out if f.startswith(basename)]
        if out_candidates:
            download_url = f'/download/{job_id}/{out_candidates[0]}'
        # prepend any warnings to logs
        if warn_msgs:
            logs = '\n'.join(warn_msgs + ([logs] if logs else []))

    return render_template(
        'index.html',
        job_id=job_id,
        logs=logs,
        download_url=download_url,
        pause=pause,
        fade=fade,
        segments=segments,
    )


@app.route('/download/<job_id>/<filename>')
def download(job_id, filename):
    dirpath = os.path.join(OUTPUT_ROOT, job_id)
    return send_from_directory(dirpath, filename, as_attachment=True)


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8020, debug=True)
