#!/usr/bin/env python3
"""
Simple Flask web UI for youtube_cutter.py.
Allows entering pause, fade, and segment triples, runs the cutter,
and serves the resulting output file for download.
"""
import os
import uuid
import subprocess
from flask import Flask, render_template, request, send_from_directory, redirect, url_for
from werkzeug.utils import secure_filename
import zipfile
import re
import sys
import urllib.request

# Create outputs directory
OUTPUT_ROOT = os.path.join(os.path.dirname(__file__), 'outputs')
os.makedirs(OUTPUT_ROOT, exist_ok=True)

app = Flask(__name__)


@app.route('/', methods=['GET', 'POST'])
def index():
    logs = None
    download_url = None
    # retain form values across requests
    job_id = ''
    pause = ''
    fade = ''
    segments = ''
    # multi-downloader video state
    multi_logs = None
    multi_download_url = None
    multi_urls = ''
    # multi-downloader audio state
    multi_logs_audio = None
    multi_download_url_audio = None
    multi_urls_audio = ''
    # multi-downloader spotify state
    multi_logs_spotify = None
    multi_download_url_spotify = None
    multi_urls_spotify = ''
    if request.method == 'POST':
        pause = request.form.get('pause', '').strip()
        fade = request.form.get('fade', '').strip()
        segments = request.form.get('segments', '').strip()
        segments_text = segments.splitlines()

        # Determine job ID (reuse if re-running, otherwise generate new)
        job_id = request.form.get('job_id') or uuid.uuid4().hex
        out_dir = os.path.join(OUTPUT_ROOT, job_id)
        os.makedirs(out_dir, exist_ok=True)

        # Collect existing uploaded MP3s (from prior run) and add new uploads
        existing = [f for f in os.listdir(out_dir) if f.lower().endswith('.mp3')]
        uploaded = request.files.getlist('files')
        warn_msgs = []
        for f in uploaded:
            if f and f.filename:
                fname = secure_filename(f.filename)
                if fname not in existing:
                    existing.append(fname)
                    f.save(os.path.join(out_dir, fname))
        if len(existing) > 9:
            warn_msgs.append(
                f"Warning: only first 9 uploaded files will be used (you uploaded {len(existing)})"
            )
            existing = existing[:9]
        uploaded_names = existing

        # Build args list, substituting uploaded files paths if used
        args = [pause, fade]
        for line in segments_text:
            parts = line.strip().split()
            if len(parts) == 3:
                if parts[0] in uploaded_names:
                    parts[0] = os.path.join(out_dir, parts[0])
                args.extend(parts)

        # Base path for output file (will result in mashup_combined.mp3)
        out_base = os.path.join(out_dir, 'mashup_combined')

        # Invoke youtube_cutter script
        cmd = ['python3', 'youtube_cutter.py'] + args + ['-o', out_base]
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        logs, _ = proc.communicate()

        # Determine output file name (pick the generated "output" file)
        files_in_out = os.listdir(out_dir)
        # look for output.* file generated by youtube_cutter
        basename = os.path.basename(out_base)
        out_candidates = [f for f in files_in_out if f.startswith(basename)]
        if out_candidates:
            download_url = f'/download/{job_id}/{out_candidates[0]}'
        # prepend any warnings to logs
        if warn_msgs:
            logs = '\n'.join(warn_msgs + ([logs] if logs else []))

    return render_template(
        'index.html',
        job_id=job_id,
        logs=logs,
        download_url=download_url,
        pause=pause,
        fade=fade,
        segments=segments,
        multi_logs=multi_logs,
        multi_download_url=multi_download_url,
        multi_urls=multi_urls,
        multi_logs_audio=multi_logs_audio,
        multi_download_url_audio=multi_download_url_audio,
        multi_urls_audio=multi_urls_audio,
        multi_logs_spotify=multi_logs_spotify,
        multi_download_url_spotify=multi_download_url_spotify,
        multi_urls_spotify=multi_urls_spotify,
    )


@app.route('/download/<job_id>/<filename>')
def download(job_id, filename):
    dirpath = os.path.join(OUTPUT_ROOT, job_id)
    return send_from_directory(dirpath, filename, as_attachment=True)


@app.route('/multi-download', methods=['GET', 'POST'])
def multi_download():
    """Download multiple YouTube URLs and zip the results."""
    # GET: redirect back to main page
    if request.method == 'GET':
        print("[multi_download] GET -- redirecting to index", file=sys.stderr)
        return redirect(url_for('index'))

    # New job directory
    job_id = uuid.uuid4().hex
    out_dir = os.path.join(OUTPUT_ROOT, job_id)
    os.makedirs(out_dir, exist_ok=True)

    print("[multi_download] POST -- starting download", file=sys.stderr)
    # Read URLs list
    multi_urls = request.form.get('multi_urls', '').strip()
    urls = [u.strip() for u in multi_urls.splitlines() if u.strip()]
    multi_logs = ''

    # Download each URL via yt-dlp
    for url in urls:
        try:
            cmd = ['yt-dlp', '-o', os.path.join(out_dir, '%(title)s.%(ext)s'), url]
            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT, text=True)
            out, _ = proc.communicate()
            multi_logs += out + '\n'
        except Exception as exc:
            multi_logs += f"Error downloading {url}: {exc}\n"

    # Zip the downloaded files
    zip_name = 'youtube_multi.zip'
    zip_path = os.path.join(out_dir, zip_name)
    try:
        with zipfile.ZipFile(zip_path, 'w') as zf:
            for fname in os.listdir(out_dir):
                if fname == zip_name:
                    continue
                # Normalize filename: keep only alphanumeric in base, replace others with hyphen; preserve extension dot
                base, ext = os.path.splitext(fname)
                safe_base = re.sub(r'[^0-9A-Za-z]', '-', base)
                safe_name = f"{safe_base}{ext}"
                zf.write(os.path.join(out_dir, fname), arcname=safe_name)
    except Exception as exc:
        multi_logs += f"Error creating zip: {exc}\n"

    multi_download_url = f'/download/{job_id}/{zip_name}'
    # Render main page with multi-downloader context
    return render_template(
        'index.html',
        job_id='', logs=None, download_url=None,
        pause='', fade='', segments='',
        multi_logs=multi_logs,
        multi_download_url=multi_download_url,
        multi_urls=multi_urls,
        # reset audio downloader panel
        multi_logs_audio=None,
        multi_download_url_audio=None,
        multi_urls_audio='',
    )

@app.route('/multi-audio', methods=['GET', 'POST'])
def multi_audio_download():
    """Download multiple YouTube URLs as MP3 and zip the results."""
    if request.method == 'GET':
        print("[multi_audio_download] GET -- redirecting to index", file=sys.stderr)
        return redirect(url_for('index'))

    print("[multi_audio_download] POST -- starting audio download", file=sys.stderr)
    job_id = uuid.uuid4().hex
    out_dir = os.path.join(OUTPUT_ROOT, job_id)
    os.makedirs(out_dir, exist_ok=True)

    multi_urls_audio = request.form.get('multi_urls_audio', '').strip()
    urls = [u.strip() for u in multi_urls_audio.splitlines() if u.strip()]
    multi_logs_audio = ''

    for url in urls:
        try:
            cmd = [
                'yt-dlp', '-x', '--audio-format', 'mp3',
                '-o', os.path.join(out_dir, '%(title)s.%(ext)s'),
                url,
            ]
            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT, text=True)
            out, _ = proc.communicate()
            multi_logs_audio += out + '\n'
        except Exception as exc:
            multi_logs_audio += f"Error downloading {url}: {exc}\n"

    zip_name = 'youtube_audio_multi.zip'
    zip_path = os.path.join(out_dir, zip_name)
    try:
        with zipfile.ZipFile(zip_path, 'w') as zf:
            for fname in os.listdir(out_dir):
                if fname == zip_name:
                    continue
                base, ext = os.path.splitext(fname)
                safe_base = re.sub(r'[^0-9A-Za-z]', '-', base)
                safe_name = f"{safe_base}{ext}"
                zf.write(os.path.join(out_dir, fname), arcname=safe_name)
    except Exception as exc:
        multi_logs_audio += f"Error creating zip: {exc}\n"

    multi_download_url_audio = f'/download/{job_id}/{zip_name}'
    return render_template(
        'index.html', job_id='', logs=None, download_url=None,
        pause='', fade='', segments='',
        multi_logs=None, multi_download_url=None, multi_urls='',
        multi_logs_audio=multi_logs_audio,
        multi_download_url_audio=multi_download_url_audio,
    multi_urls_audio=multi_urls_audio,
    )

@app.route('/multi-spotify', methods=['GET', 'POST'])
def multi_spotify_download():
    """Download multiple Spotify URLs as audio and zip the results."""
    if request.method == 'GET':
        print("[multi_spotify_download] GET -- redirecting to index", file=sys.stderr)
        return redirect(url_for('index'))

    print("[multi_spotify_download] POST -- starting spotify download", file=sys.stderr)
    job_id = uuid.uuid4().hex
    out_dir = os.path.join(OUTPUT_ROOT, job_id)
    os.makedirs(out_dir, exist_ok=True)

    multi_urls_spotify = request.form.get('multi_urls_spotify', '').strip()
    urls = [u.strip() for u in multi_urls_spotify.splitlines() if u.strip()]
    multi_logs_spotify = ''

    for url in urls:
        try:
            cmd = [
                'yt-dlp', '-x', '--audio-format', 'mp3',
                '-o', os.path.join(out_dir, '%(title)s.%(ext)s'),
                url,
            ]
            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT, text=True)
            out, _ = proc.communicate()
            multi_logs_spotify += out + '\n'
        except Exception as exc:
            multi_logs_spotify += f"Error downloading {url}: {exc}\n"

    zip_name = 'spotify_audio_multi.zip'
    zip_path = os.path.join(out_dir, zip_name)
    # Check downloaded mp3s, if empty try preview-url fallback
    audio_files = [f for f in os.listdir(out_dir) if f.lower().endswith('.mp3')]
    if not audio_files:
        # Try spotdl per-URL if available
        try:
            import spotdl  # noqa: F401
            multi_logs_spotify += "Attempting full-track download via spotdl...\n"
            for url in urls:
                try:
                    subprocess.run(['spotdl', '--output', out_dir, url], check=True)
                    multi_logs_spotify += f"Downloaded full track for {url}\n"
                except subprocess.CalledProcessError as exc:
                    multi_logs_spotify += f"spotdl failed for {url}: {exc}\n"
            audio_files = [f for f in os.listdir(out_dir) if f.lower().endswith('.mp3')]
        except ModuleNotFoundError:
            multi_logs_spotify += "spotdl not installed; falling back to preview snippet...\n"
        except Exception as exc:
            multi_logs_spotify += f"spotdl download error: {exc}\n"
    if not audio_files:
        multi_logs_spotify += "No audio files downloaded; could be DRM-protected.\n"
    try:
        with zipfile.ZipFile(zip_path, 'w') as zf:
            for fname in os.listdir(out_dir):
                if fname == zip_name:
                    continue
                base, ext = os.path.splitext(fname)
                safe_base = re.sub(r'[^0-9A-Za-z]', '-', base)
                safe_name = f"{safe_base}{ext}"
                zf.write(os.path.join(out_dir, fname), arcname=safe_name)
    except Exception as exc:
        multi_logs_spotify += f"Error creating zip: {exc}\n"

    multi_download_url_spotify = f'/download/{job_id}/{zip_name}'
    return render_template(
        'index.html', job_id='', logs=None, download_url=None,
        pause='', fade='', segments='',
        multi_logs=None, multi_download_url=None, multi_urls='',
        multi_logs_audio=None, multi_download_url_audio=None, multi_urls_audio='',
        multi_logs_spotify=multi_logs_spotify,
        multi_download_url_spotify=multi_download_url_spotify,
        multi_urls_spotify=multi_urls_spotify,
    )

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8020, debug=True)
